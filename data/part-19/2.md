---
path: '/part-19/2-type-parameters'
title: 'Type Parameters'
hidden: false
---

<text-box variant='learningObjectives' name="Learning objectives">

After this section

*   You know what an algebraic datatype is
*   You know what fields are (in the FP context)
*   You know what a constructor is (in the FP context)

</text-box>


We introduced type parameters and parametric polymorphism when introducing lists in Lecture 2. Since then, we’ve seen other parameterized types like `Maybe` and `Either`. Now we’ll learn how we can define our own parameterized types.


### Defining Parameterized Types

The definition for `Maybe` is:

```haskell
    data Maybe a = Nothing | Just a
```
What’s `a`? We define a parameterized type by mentioning a _type variable_ (`a` in this case) on the left side of the `=` sign. We can then use the same type variable in fields for our constructors. This is analogous to polymorphic functions. Instead of defining separate functions
```haskell
headInt :: [Int] -> Int
headBool :: [Bool] -> Bool
```
and so on, we define one function `head :: [a] -> a` that works for all types `a`. Similarly, instead of defining multiple types
```haskell
data MaybeInt = NothingInt | JustInt Int
data MaybeBool = NothingBool | JustBool Bool
```
we define one type `Maybe a` that works for all types `a`.

Here’s our first own parameterized type `Described`. The values of type `Described a` contain a value of type `a` and a `String` description.
```haskell
data Described a = Describe a String

getValue :: Described a -> a
getValue (Describe x _) = x

getDescription :: Described a -> String
getDescription (Describe _ desc) = desc

Prelude> :t Describe
Describe :: a -> String -> Described a
Prelude> :t Describe True "This is true"
Describe True "This is true" :: Described Bool
Prelude> getValue (Describe 3 "a number")
3
Prelude> getDescription (Describe 3 "a number")
"a number"
```

### Syntactic Note

In the above definitions, we’ve used `a` as a type variable. However any word that starts with a lower case letter is fine. We could have defined `Maybe` like this:
```haskell
data Maybe theType = Nothing | Just theType
```
The rules for Haskell identifiers are:

*   Type variables and names for functions and values start lower case (e.g. `a`, `map`, `xs`)
*   Type names and constructor names start with upper case (e.g. `Maybe`, `Just`, `Card`, `Heart`)

Note that a type and its constructor can have the same name. This is very common in Haskell code for types that only have one constructor. In this material we try to avoid it to avoid confusion. Here are some examples:

```haskell
data Pair a = Pair a a
data Report = Report Int String String

Prelude> :t Pair
Pair :: a -> a -> Pair a
```
Beware of mixing up types and constructors. Luckily types and constructors can never occur in the same context, so you get a nice error:

```haskell
Prelude> Maybe                              -- trying to use a type name as a value
<interactive>:1:1: error:
    • Data constructor not in scope: Maybe

Prelude> undefined :: Nothing               -- trying to use a constructor as a type
<interactive>:2:14: error:
    Not in scope: type constructor or class ‘Nothing’
```
### Sidenote: Multiple Type Parameters

Types can have multiple type parameters. The syntax is similar to defining functions with many arguments. Here’s the definition of the standard `Either` type:

```haskell
data Either a b = Left a | Right b
```
